.program hx711

; Reads data from the HX711, a 24 bit ADC designed for load cells
; 1) D_IN falls
; 2) Wait at least 0.1 us
; 3) Drive CLK high for 1 us
; 4) Read D_IN
; 5) Drive CLK low for 1 us
; 6) Repeat from (3) until 24 reads complete
; 7) Output data
; 8) Return to (1)

.side_set 1
write_data:
    mov isr y             side 0      ; Copy scratch y to isr
    push                  side 0      ; push latest reading
    out null 32           side 0      ; clear data request 
wait_loop:
    jmp !osre write_data  side 0      ; if requested, write data
    jmp pin wait_loop     side 0      ; cycle until jump pin is low
    set x 23              side 0      ; set loop counter
    in null 8             side 1  [4] ; Shift in 8 0 to isr
bit_loop:
    in  pins 1            side 0  [4] ; read data 
    jmp x-- bit_loop      side 1  [4] ; repeat loop till x empty
    mov y isr             side 0      ; move most recent reading to scratch y
    jmp wait_loop         side 0

% c-sdk {
#include "hardware/clocks.h"
#include "hardware/gpio.h"

typedef struct HX711_{
    const uint8_t pio_num;
    const uint8_t dat_pin;
    const uint8_t clk_pin;
    PIO pio;
    uint sm;
    uint32_t val;
} HX711;

static inline void hx711_program_init(HX711* scale, uint offset) {
    pio_gpio_init(scale->pio, scale->dat_pin);
    pio_gpio_init(scale->pio, scale->clk_pin);
    pio_sm_set_consecutive_pindirs(scale->pio, scale->sm, scale->clk_pin, 1, true);
    pio_sm_set_consecutive_pindirs(scale->pio, scale->sm, scale->dat_pin, 1, false);

    pio_sm_config c = hx711_program_get_default_config(offset);
    
    sm_config_set_sideset_pins(&c, scale->clk_pin);
    sm_config_set_jmp_pin(&c, scale->dat_pin);
    sm_config_set_in_pins(&c, scale->dat_pin);
    
    sm_config_set_in_shift(&c, true, false, 0);
    sm_config_set_out_shift(&c, false, true, 32);

    // Each bit should take 2us over 12 cycles = 6cycles per us = 6e6Hz
    float div = (float)clock_get_hz(clk_sys)/6000000;
    sm_config_set_clkdiv(&c, div);
    
    pio_sm_init(scale->pio, scale->sm, offset, &c);
    pio_sm_set_enabled(scale->pio, scale->sm, true);
}

static inline void hx711_setup(HX711* scale){
  scale->pio =  (scale->pio_num==0) ? pio0 : pio1;
  uint offset = pio_add_program(scale->pio, &hx711_program);
  scale->sm = pio_claim_unused_sm(scale->pio, true);
  hx711_program_init(scale, offset);
}

static inline void hx711_read(HX711* scale){
    pio_sm_put(scale->pio, scale->sm, 1);
    uint32_t num = pio_sm_get_blocking(scale->pio, scale->sm);
    scale->val = num;
    uint8_t count = 32;
    while(num){
	scale->val <<= 1;
	scale->val |= num&1;
	num >>= 1;
	count -= 1;
    }
    scale->val <<= count;
    return;
}
%}