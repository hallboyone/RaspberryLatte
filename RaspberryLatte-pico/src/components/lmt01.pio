/*
; Reads data from the LMT01, a TI tempurature sensor that transmits some number of
; pulses porportional to the measured tempurature

.program lmt01
    set y, 0               ; Reset counter
    wait 0 pin 0           ; Wait for start of pulse train
counting_loop:             ; Loop until pin goes low or time is up
    jmp pin no_pulse       ; No pulse, skip increment steps
    mov x, !y	             ; Pulse. Increment y using (y+1)=!((!y)-1)
    jmp x-- dec_label                     
dec_label:
    mov y, !x
    set x 25               ; Restart timer
    wait 1 pin 0           ; Wait for pin to go high again
no_pulse:
    jmp x-- counting_loop  ; Timer not expired. Loop again
    in  y, 32              ; Send counter value to program
    
%c-sdk{*/
#include "hardware/clocks.h"
#include "hardware/gpio.h"
#include "pico/time.h"

static const int PULSE_COUNTS [20] = {181,  338,  494,  651,
			       808,  966,  1125, 1284,
			       1443, 1603, 1762, 1923,
			       2084, 2245, 2407, 2569,
			       2731, 2894, 3058, 3220};

static const float PULSE_SLOPES [19] = {0.063694268,
				 0.064102564,
				 0.063694268,
				 0.063694268,
				 0.063291139,
				 0.062893082,
				 0.062893082,
				 0.062893082,
				 0.062500000,
				 0.062893082,
				 0.062111801,
				 0.062111801,
				 0.062111801,
				 0.061728395,
				 0.061728395,
				 0.061728395,
				 0.061349693,
				 0.060975610,
				 0.061728395};

static uint _pio_num;
static uint _sig_pin;
static PIO _pio;
static  _sm;
static uint32_t _val;
static int _latest_temp = 0;

static int getTemp(int pulse_count){
  if (pulse_count < PULSE_COUNTS[1]){
    return  16*(-40 + (pulse_count - PULSE_COUNTS[ 0]) * PULSE_SLOPES[0]);
  } else if (pulse_count < PULSE_COUNTS[2]){
    return  16*(-30 + (pulse_count - PULSE_COUNTS[ 1]) * PULSE_SLOPES[1]);
  } else if (pulse_count < PULSE_COUNTS[3]){
    return  16*(-20 + (pulse_count - PULSE_COUNTS[ 2]) * PULSE_SLOPES[2]);
  } else if (pulse_count < PULSE_COUNTS[4]){
    return  16*(-10 + (pulse_count - PULSE_COUNTS[ 3]) * PULSE_SLOPES[3]);
  } else if (pulse_count < PULSE_COUNTS[5]){
    return  16*(  0 + (pulse_count - PULSE_COUNTS[ 4]) * PULSE_SLOPES[4]);
  } else if (pulse_count < PULSE_COUNTS[6]){
    return  16*( 10 + (pulse_count - PULSE_COUNTS[ 5]) * PULSE_SLOPES[5]);
  } else if (pulse_count < PULSE_COUNTS[7]){
    return  16*( 20 + (pulse_count - PULSE_COUNTS[ 6]) * PULSE_SLOPES[6]);
  } else if (pulse_count < PULSE_COUNTS[8]){
    return  16*( 30 + (pulse_count - PULSE_COUNTS[ 7]) * PULSE_SLOPES[7]);
  } else if (pulse_count < PULSE_COUNTS[9]){
    return  16*( 40 + (pulse_count - PULSE_COUNTS[ 8]) * PULSE_SLOPES[8]);
  } else if (pulse_count < PULSE_COUNTS[10]){
    return  16*( 50 + (pulse_count - PULSE_COUNTS[ 9]) * PULSE_SLOPES[9]);
  } else if (pulse_count < PULSE_COUNTS[11]){
    return  16*( 60 + (pulse_count - PULSE_COUNTS[10]) * PULSE_SLOPES[10]);
  } else if (pulse_count < PULSE_COUNTS[12]){
    return  16*( 70 + (pulse_count - PULSE_COUNTS[11]) * PULSE_SLOPES[11]);
  } else if (pulse_count < PULSE_COUNTS[13]){
    return  16*( 80 + (pulse_count - PULSE_COUNTS[12]) * PULSE_SLOPES[12]);
  } else if (pulse_count < PULSE_COUNTS[14]){
    return  16*( 90 + (pulse_count - PULSE_COUNTS[13]) * PULSE_SLOPES[13]);
  } else if (pulse_count < PULSE_COUNTS[15]){
    return  16*(100 + (pulse_count - PULSE_COUNTS[14]) * PULSE_SLOPES[14]);
  } else if (pulse_count < PULSE_COUNTS[16]){
    return  16*(110 + (pulse_count - PULSE_COUNTS[15]) * PULSE_SLOPES[15]);
  } else if (pulse_count < PULSE_COUNTS[17]){
    return  16*(120 + (pulse_count - PULSE_COUNTS[16]) * PULSE_SLOPES[16]);
  } else if (pulse_count < PULSE_COUNTS[18]){
    return  16*(130 + (pulse_count - PULSE_COUNTS[17]) * PULSE_SLOPES[17]);
  } else {
    return  16*(140 + (pulse_count - PULSE_COUNTS[18]) * PULSE_SLOPES[18]);
  } 
}

static inline void lmt01_program_init(uint offset, uint dat_pin) {
    // Setup dat_pin
    pio_sm_set_consecutive_pindirs(_pio, _sm, dat_pin, 1, false);
    pio_gpio_init(_pio, dat_pin);

    pio_sm_config c = lmt01_program_get_default_config(offset);
    
    sm_config_set_jmp_pin(&c, dat_pin);
    sm_config_set_in_pins(&c, dat_pin);
    
    sm_config_set_in_shift(&c, false, true, 32);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    
    // Each clock cycle should be 0.5us -> 2000000 Hz
    float div = (float)clock_get_hz(clk_sys)/2000000.0;
    sm_config_set_clkdiv(&c, div);
    
    pio_sm_init(_pio, _sm, offset, &c);
    pio_sm_set_enabled(_pio, _sm, true);
}


static inline int lmt01_read(){
    return getTemp(pio_sm_get_blocking(_pio, _sm));
}

static inline void lmt01_setup(uint8_t pio_num, uint8_t sig_pin){
    _pio =  (pio_num==0 ? pio0 : pio1);
    uint offset = pio_add_program(_pio, &lmt01_program);
    _sm = pio_claim_unused_sm(_pio, true);
    lmt01_program_init(offset, thermo->sig_pin);
    lmt01_read();
    lmt01_read();
}

/**
 * Clears the RX buffer and saves the most recent value. The LMT01 takes around 50ms
 * pre reading so this procedure ensures a query can be answered quickly with the
 * most recent value.
 */
static void lmt01_maintainer(){
  while(!pio_sm_is_rx_fifo_empty()){
    latest_temp = lmt01_read();
  }
}

static void lmt01_read_handler(int* value, int len){
  sendMessage(MSG_ID_GET_TEMP, &latest)
}
%}