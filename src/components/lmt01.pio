; Reads data from the LMT01, a TI tempurature sensor that transmits some number of
; pulses porportional to the measured tempurature

.program lmt01
    set y, 0               ; Reset counter
    wait 0 pin 0           ; Wait for start of pulse train
counting_loop:             ; Loop until pin goes low or time is up
    jmp pin no_pulse       ; No pulse, skip increment steps
    mov x, !y	           ; Pulse. Increment y using (y+1)=!((!y)-1)
    jmp x-- dec_label                     
dec_label:
    mov y, !x
    set x 25               ; Restart timer
    wait 1 pin 0           ; Wait for pin to go high again
no_pulse:
    jmp x-- counting_loop  ; Timer not expired. Loop again
    in  y, 32              ; Send counter value to program
    
%c-sdk{
#include "hardware/clocks.h"
#include "hardware/gpio.h"
#include "pico/time.h"

typedef struct {
    uint pio_num;
    uint sig_pin;
    PIO pio;
    uint sm;
    uint32_t val;
} LMT01;

static const int PULSE_COUNTS [20] = {181,  338,  494,  651,
			       808,  966,  1125, 1284,
			       1443, 1603, 1762, 1923,
			       2084, 2245, 2407, 2569,
			       2731, 2894, 3058, 3220};

static const float PULSE_SLOPES [19] = {0.063694268,
				 0.064102564,
				 0.063694268,
				 0.063694268,
				 0.063291139,
				 0.062893082,
				 0.062893082,
				 0.062893082,
				 0.062500000,
				 0.062893082,
				 0.062111801,
				 0.062111801,
				 0.062111801,
				 0.061728395,
				 0.061728395,
				 0.061728395,
				 0.061349693,
				 0.060975610,
				 0.061728395};

static int getTemp(int pulse_count){
  if (pulse_count < PULSE_COUNTS[1]){
    return -40 + (pulse_count - PULSE_COUNTS[0]) * PULSE_SLOPES[0];
  } else if (pulse_count < PULSE_COUNTS[2]){
    return -30 + (pulse_count - PULSE_COUNTS[1]) * PULSE_SLOPES[1];
  } else if (pulse_count < PULSE_COUNTS[3]){
    return -20 + (pulse_count - PULSE_COUNTS[2]) * PULSE_SLOPES[2];
  } else if (pulse_count < PULSE_COUNTS[4]){
    return -10 + (pulse_count - PULSE_COUNTS[3]) * PULSE_SLOPES[3];
  } else if (pulse_count < PULSE_COUNTS[5]){
    return   0 + (pulse_count - PULSE_COUNTS[4]) * PULSE_SLOPES[4];
  } else if (pulse_count < PULSE_COUNTS[6]){
    return  10 + (pulse_count - PULSE_COUNTS[5]) * PULSE_SLOPES[5];
  } else if (pulse_count < PULSE_COUNTS[7]){
    return  20 + (pulse_count - PULSE_COUNTS[6]) * PULSE_SLOPES[6];
  } else if (pulse_count < PULSE_COUNTS[8]){
    return  30 + (pulse_count - PULSE_COUNTS[7]) * PULSE_SLOPES[7];
  } else if (pulse_count < PULSE_COUNTS[9]){
    return  40 + (pulse_count - PULSE_COUNTS[8]) * PULSE_SLOPES[8];
  } else if (pulse_count < PULSE_COUNTS[10]){
    return  50 + (pulse_count - PULSE_COUNTS[9]) * PULSE_SLOPES[9];
  } else if (pulse_count < PULSE_COUNTS[11]){
    return  60 + (pulse_count - PULSE_COUNTS[10]) * PULSE_SLOPES[10];
  } else if (pulse_count < PULSE_COUNTS[12]){
    return  70 + (pulse_count - PULSE_COUNTS[11]) * PULSE_SLOPES[11];
  } else if (pulse_count < PULSE_COUNTS[13]){
    return  80 + (pulse_count - PULSE_COUNTS[12]) * PULSE_SLOPES[12];
  } else if (pulse_count < PULSE_COUNTS[14]){
    return  90 + (pulse_count - PULSE_COUNTS[13]) * PULSE_SLOPES[13];
  } else if (pulse_count < PULSE_COUNTS[15]){
    return 100 + (pulse_count - PULSE_COUNTS[14]) * PULSE_SLOPES[14];
  } else if (pulse_count < PULSE_COUNTS[16]){
    return 110 + (pulse_count - PULSE_COUNTS[15]) * PULSE_SLOPES[15];
  } else if (pulse_count < PULSE_COUNTS[17]){
    return 120 + (pulse_count - PULSE_COUNTS[16]) * PULSE_SLOPES[16];
  } else if (pulse_count < PULSE_COUNTS[18]){
    return 130 + (pulse_count - PULSE_COUNTS[17]) * PULSE_SLOPES[17];
  } else {
    return 140 + (pulse_count - PULSE_COUNTS[18]) * PULSE_SLOPES[18];
  } 
}

static inline void lmt01_program_init(PIO pio, uint sm, uint offset, uint dat_pin) {
    // Setup dat_pin
    pio_sm_set_consecutive_pindirs(pio, sm, dat_pin, 1, false);
    pio_gpio_init(pio, dat_pin);

    pio_sm_config c = lmt01_program_get_default_config(offset);
    
    sm_config_set_jmp_pin(&c, dat_pin);
    sm_config_set_in_pins(&c, dat_pin);
    
    sm_config_set_in_shift(&c, false, true, 32);
    //sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    
    // Each clock cycle should be 0.5us -> 2000000 Hz
    float div = (float)clock_get_hz(clk_sys)/2000000.0;
    sm_config_set_clkdiv(&c, div);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}


static inline void lmt01_read(LMT01 * thermo){
    thermo->val = pio_sm_get_blocking(thermo->pio, thermo->sm);
    //thermo->val = raw_val;//getTemp(raw_val);
    return;
}

static inline void lmt01_setup(LMT01 * thermo){
    thermo->pio =  (thermo->pio_num==0) ? pio0 : pio1;
    uint offset = pio_add_program(thermo->pio, &lmt01_program);
    thermo->sm = pio_claim_unused_sm(thermo->pio, true);
    lmt01_program_init(thermo->pio, thermo->sm, offset, thermo->sig_pin);
    lmt01_read(thermo);
    lmt01_read(thermo);
}
%}